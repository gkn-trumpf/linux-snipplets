#/bin/bash

declare -A foregroundColors;
foregroundColors=(\
  ['black']='\E[0;47m'\
  ['red']='\E[0;31m'\
  ['green']='\E[0;32m'\
  ['yellow']='\E[0;33m'\
  ['blue']='\E[0;34m'\
  ['magenta']='\E[0;35m'\
  ['cyan']='\E[0;36m'\
  ['white']='\E[0;37m'\
  ['reset']='\e[0m'\
);

declare -A vanityLevel;
vanityLevel=(\
  ['error']='\E[0;31m'\
  ['success']='\E[0;32m'\
  ['warning']='\E[0;33m'\
  ['info']='\E[0;34m'\
  ['reset']='\e[0m'\
);

#
# @param string vanity (ok|warning|error)
# @param string message
function message {
  echo -e "${vanityLevel[${1}]}${2}${vanityLevel['reset']}";
}


#
# Echo'es and logs simultanously
#
# @param string message
# @param string logFile
function echo_log {
  if [[ ! -d $(dirname ${1}) ]];
  then
    message warning "Path to ${1} does not exist!";
    exit 1;
  fi

  # fetch stdin
  while read data; do
    printf "${data}\n";
    printf "${data}\n" >> ${1};
  done
}

# @param string logFile
function purge_log {
  test -f ${1} && {
    truncate -s 0 ${1};
  }
}


#
# @param string command to execute
function try {
  $(echo $@);

  if [[ $? -ne 0 ]];
  then
        message error "Error: Failed executing\e[0m\n$@";
        return 1;
  fi

  return 0;
}


#
# @param string $0 (script-name)
function get_threads {
  declare -i _threads;
  _threads=$(pgrep -f ${1} | wc -l);

  echo $_threads;
}

# 
# @param string $0 (script-name)
# @param int    number of allowed threads
function limit_threads {
  declare -i _threads;
  _threads=$(pgrep -f ${1} | wc -l);

  if [[ ${_threads} > ${2} ]];
  then
        message warning "Threads limit reached!";
        exit 1;
  fi

  message info "Creating thread ${_threads}";
}
